import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import ast.Program;
import ast.Statement;
import ast.Expression;
import ast.ExpressionStatement;
import ast.AssignmentExpression;
import ast.BinaryExpression;
import ast.UnaryExpression;
import ast.TermExpression;
import ast.IdentifierExpression;
import ast.Operator;
import ast.Primary;
import ast.Lvalue;
import ast.Member;
import ast.Constant;
import ast.IntegerLiteral;
import ast.DoubleLiteral;
import ast.StringLiteral;
import ast.TrueLiteral;
import ast.FalseLiteral;
import ast.NullLiteral;
import ast.Call;
import ast.ExtendedCall;
import ast.LvalueCall;
import ast.AnonymousFunctionCall;
import ast.CallSuffix;
import ast.NormCall;
import ast.MethodCall;
import ast.Block;
import ast.ArrayDef;
import ast.FunctionDef;


parser code
{:
    /** Report a non fatal error (or warning).
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_error(String message, Object info)
    {
        String error = "";
        if (! (info instanceof Symbol))
            info = cur_token;
        if( info instanceof Symbol ) {
            int line = ((Symbol)info).left;
            int column = ((Symbol)info).right;
            error = line  + ":" + column;
        }
        error = error + ": error: " + message;
        System.err.println(error);
        System.err.flush();
    }

    /** Report a fatal error.
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_fatal_error(String   message, Object   info) throws java.lang.Exception
    {
        /* stop parsing (not really necessary since we throw an exception, but) */
        done_parsing();

        /* use the normal error message reporting to put out the message */
        report_error(message, info);

        /* throw an exception */
        throw new Exception("Can't recover from previous error(s)");
    }

    public int getLine() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.left;
    }

    public int getColumn() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.right;
    }
:};


terminal WHILE, FOR, IF, ELSE, RETURN, BREAK, CONTINUE, FUNCTION, TRUE, FALSE, NIL;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, SEMICOLON, COLON, LEFT_BRACKET, RIGHT_BRACKET, OPEN_BLOCK, CLOSE_BLOCK, DOT, DOUBLE_DOT, COMMA;
terminal DOUBLE_COLON;
terminal ASSIGN;
terminal MUL, DIV, MOD;
terminal PLUS, MINUS, UMINUS, PLUS_PLUS, MINUS_MINUS;
terminal GREATER, LESS, NOT_EQUAL, LESS_OR_EQUAL, GREATER_OR_EQUAL, CMP_EQUAL;
terminal LOGIC_AND, LOGIC_OR, NOT;
terminal QUASI_ESC, QUASI_EXEC, QUASI_OPEN, QUASI_CLOSE;

terminal java.lang.String ID;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Double  REAL_LITERAL;
terminal java.lang.String  STRING_LITERAL;

non terminal Program program;
non terminal ArrayList<Statement> stmtlist;
non terminal Statement stmt;
non terminal Expression expr;
non terminal ArrayList<Expression> elist;
non terminal ifstmt;
non terminal elsestmt;
non terminal whilestmt;
non terminal forstmt;
non terminal returnstmt;
non terminal returnStmt;
non terminal Block block;
non terminal FunctionDef funcdef;
non terminal String functionName;
non terminal AssignmentExpression assignexpr;
non terminal TermExpression term;
non terminal Operator op;
non terminal Lvalue lvalue;
non terminal Primary primary;
non terminal Call call;
non terminal ArrayDef arraydef;
non terminal Constant const;
non terminal Member member;
non terminal CallSuffix callsuffix;
non terminal NormCall normcall;
non terminal MethodCall methodcall;
non terminal objectdef;
non terminal indexed;
non terminal indexedelem;
non terminal ArrayList<String> idlist;
// non terminal idList;

precedence right ASSIGN;
precedence left LOGIC_OR;
precedence left LOGIC_AND;
precedence nonassoc  CMP_EQUAL, NOT_EQUAL;
precedence nonassoc  GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence right NOT,PLUS_PLUS, MINUS_MINUS, UMINUS;
precedence left  DOT, DOUBLE_DOT;
precedence left LEFT_BRACKET, RIGHT_BRACKET;
precedence left  LEFT_PARENTHESIS, RIGHT_PARENTHESIS;
precedence nonassoc IF;
precedence nonassoc ELSE;

start with program;


program ::=	 /*Empty program*/
			 {:
			 	RESULT = new Program();
			 	RESULT.setLine(0);
			 	RESULT.setColumn(0);
			 :}
			| stmtlist:stlist
			 {:
			 	RESULT = new Program(stlist);
			 	RESULT.setLine(stlistleft);
			 	RESULT.setColumn(stlistright);
			 :}
			;

stmtlist  ::= stmt:st
			  {:
			  	RESULT = new ArrayList<Statement>();
			  	RESULT.add(st);
			  :}
			| stmtlist:stlist stmt:st
			  {:
			  	stlist.add(st);
			  	RESULT = stlist;
			  :}
			;


stmt ::=	 expr:ex SEMICOLON
			{:
				RESULT = new ExpressionStatement(ex);
				RESULT.setLine(exleft);
				RESULT.setColumn(exright);
			:}
			|ifstmt
			|whilestmt
			|forstmt
			|returnstmt
			|BREAK SEMICOLON
			|CONTINUE SEMICOLON
			|block
			|funcdef
			|SEMICOLON
			;

expr ::=	assignexpr
			|expr:ex1 op:oper expr:ex2
			{:
				RESULT = new BinaryExpression(oper, ex1, ex2);
				RESULT.setLine(ex1left);
				RESULT.setColumn(ex1right);
			:}
			|term
			;


op ::=       PLUS
			{:
				RESULT = Operator.PLUS;
			:}
            |MINUS
            {:
				RESULT = Operator.MINUS;
			:}
            |MUL
            {:
				RESULT = Operator.MUL;
			:}
            |DIV
            {:
				RESULT = Operator.DIV;
			:}
            |MOD
            {:
				RESULT = Operator.MOD;
			:}
            |GREATER
            {:
				RESULT = Operator.GREATER;
			:}
            |GREATER_OR_EQUAL
            {:
				RESULT = Operator.GREATER_OR_EQUAL;
			:}
            |LESS
            {:
				RESULT = Operator.LESS;
			:}
            |LESS_OR_EQUAL
            {:
				RESULT = Operator.LESS_OR_EQUAL;
			:}
            |CMP_EQUAL
            {:
				RESULT = Operator.CMP_EQUAL;
			:}
            |NOT_EQUAL
            {:
				RESULT = Operator.NOT_EQUAL;
			:}
            |LOGIC_AND
            {:
				RESULT = Operator.LOGIC_AND;
			:}
            |LOGIC_OR
            {:
				RESULT = Operator.LOGIC_OR;
			:}
            | NOT
            {:
				RESULT = Operator.LOGIC_NOT;
			:}
            ;

term ::=	 LEFT_PARENTHESIS expr RIGHT_PARENTHESIS
			{:
				/**/
			:}
			|MINUS expr:ex
			{:
				RESULT = new UnaryExpression(Operator.MINUS, ex, null);
				RESULT.setLine(exleft);
				RESULT.setColumn(exright);
			:}
			 %prec UMINUS
			|NOT expr:ex
			{:
				RESULT = new UnaryExpression(Operator.LOGIC_NOT, ex, null);
				RESULT.setLine(exleft);
				RESULT.setColumn(exright);
			:}
			|QUASI_OPEN expr QUASI_CLOSE
			|QUASI_ESC expr
			|QUASI_EXEC expr
			|PLUS_PLUS lvalue:lval
			{:
				RESULT = new UnaryExpression(Operator.PLUS_PLUS, null, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}
			|lvalue:lval PLUS_PLUS
			{:
				RESULT = new UnaryExpression(Operator.PLUS_PLUS, null, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}
			|MINUS_MINUS lvalue:lval
			{:
				RESULT = new UnaryExpression(Operator.MINUS_MINUS, null, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}
			|lvalue:lval MINUS_MINUS
			{:
				RESULT = new UnaryExpression(Operator.MINUS_MINUS, null, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}
			|primary
			;

assignexpr ::= 	lvalue:lval ASSIGN expr:ex
			{:
				RESULT = new AssignmentExpression(lval, ex);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}
			;


primary ::= lvalue
			|call
			|objectdef
			|arraydef
			|LEFT_PARENTHESIS funcdef RIGHT_PARENTHESIS
			|const
			;

lvalue ::=   ID:id
			{:
				RESULT = new IdentifierExpression(id, true);	// boolean value used to indicate local/global scope
				RESULT.setLine(idleft);
				RESULT.setColumn(idright);
			:}
			|DOUBLE_COLON ID:id
			{:
				RESULT = new IdentifierExpression(id, false); // boolean value used to indicate local/global scope
				RESULT.setLine(idleft);
				RESULT.setColumn(idright);
			:}
			|member
			;


member ::= lvalue:lval DOT ID:id
			{:
				RESULT = new Member(lval, id, null, null);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);				
			:}
			|lvalue:lval LEFT_BRACKET expr:ex RIGHT_BRACKET
			{:
				RESULT = new Member(lval, null, null, ex);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);				
			:}
			|call:cl DOT ID:id
			{:
				RESULT = new Member(null, id, cl, null);
				RESULT.setLine(clleft);
				RESULT.setColumn(clright);				
			:}
			|call:cl LEFT_BRACKET expr:ex RIGHT_BRACKET
			{:
				RESULT = new Member(null, null, cl, ex);
				RESULT.setLine(clleft);
				RESULT.setColumn(clright);
			:}
			;



call   ::= call:cl LEFT_PARENTHESIS elist:el RIGHT_PARENTHESIS
			{:
				RESULT = new ExtendedCall(cl, el);
				RESULT.setLine(elleft);
				RESULT.setColumn(elright);
			:}
			|lvalue:lval callsuffix:clsuffix
			{:
				RESULT = new LvalueCall(lval, clsuffix);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}
			|LEFT_PARENTHESIS funcdef:fdef RIGHT_PARENTHESIS LEFT_PARENTHESIS elist:el RIGHT_PARENTHESIS
			{:
				RESULT = new AnonymousFunctionCall(fdef, el);
				RESULT.setLine(fdefleft);
				RESULT.setColumn(fdefright);
			:}
			;



callsuffix ::= normcall
			|methodcall
			;



normcall ::= LEFT_PARENTHESIS elist:el RIGHT_PARENTHESIS
			{:
				RESULT = new NormCall(el);
				RESULT.setLine(elleft);
				RESULT.setColumn(elright);
			:}
			;


methodcall ::=  DOUBLE_DOT ID:id LEFT_PARENTHESIS elist:el RIGHT_PARENTHESIS
			{:
				RESULT = new MethodCall(id, el);
				RESULT.setLine(idleft);
				RESULT.setColumn(idright);
			:}
			;


elist 	   	::= 
		  	| expr:ex
		  	{:
			  	RESULT = new ArrayList<Expression>();
			  	RESULT.add(ex);
		  	:}
		  	| elist:el COMMA expr:ex
		  	{:
		  		el.add(ex);
		  		RESULT = el;
		  	:};


objectdef ::= OPEN_BLOCK indexed:ind CLOSE_BLOCK
		  ;

indexed ::= 
		  | expr:ex1 COLON expr:ex2	indexedelem:indelem
		  ;

indexedelem ::=
			|COMMA expr:ex1 COLON expr:ex2 indexedelem:indelem
			;	  


arraydef::= LEFT_BRACKET elist:el RIGHT_BRACKET
			{:
				RESULT = new ArrayDef(el);
				RESULT.setLine(elleft);
				RESULT.setColumn(elright);
			:}
			;


block ::=   OPEN_BLOCK stmtlist:stlist CLOSE_BLOCK
			{:
				RESULT = new Block(stlist);
				RESULT.setLine(stlistleft);
				RESULT.setColumn(stlistright);
			:}
			;

funcdef ::= FUNCTION  functionName:funcName LEFT_PARENTHESIS idlist:idl RIGHT_PARENTHESIS block:bl
			{:
				RESULT = new FunctionDef(funcName, idl, bl);
				RESULT.setLine(funcNameleft);
				RESULT.setColumn(funcNameright);
			:}
			| FUNCTION  functionName:funcName LEFT_PARENTHESIS idlist:idl RIGHT_PARENTHESIS OPEN_BLOCK CLOSE_BLOCK
			{:
				RESULT = new FunctionDef(funcName, idl, null);
				RESULT.setLine(funcNameleft);
				RESULT.setColumn(funcNameright);
			:}
			;


functionName::= 
			|ID:id
			{:
				RESULT = id;
			:}
			;

const ::= INTEGER_LITERAL:literal
			{:
				RESULT = new IntegerLiteral(literal);
				RESULT.setLine(literalleft);
				RESULT.setColumn(literalright);
			:}
			|REAL_LITERAL:literal
			{:
				RESULT = new DoubleLiteral(literal);
				RESULT.setLine(literalleft);
				RESULT.setColumn(literalright);
			:}
			|STRING_LITERAL:literal
			{:
				RESULT = new StringLiteral(literal);
				RESULT.setLine(literalleft);
				RESULT.setColumn(literalright);
			:}
			|NIL:literal
			{:
				RESULT = new NullLiteral();
				RESULT.setLine(literalleft);
				RESULT.setColumn(literalright);
			:}
			|TRUE:literal
			{:
				RESULT = new TrueLiteral();
				RESULT.setLine(literalleft);
				RESULT.setColumn(literalright);
			:}
			|FALSE:literal
			{:
				RESULT = new FalseLiteral();
				RESULT.setLine(literalleft);
				RESULT.setColumn(literalright);
			:}
			;

idlist	::= 
			| ID:id
			{:
				RESULT = new ArrayList<String>();
				RESULT.add(id);
			:}
			| idlist:idl COMMA ID:id
			{:
				idl.add(id);
				RESULT = idl;
			:};

/*idlist ::= 
			|ID idList
			{:
				RESULT = new ArrayList<String>();
			:}
			;


idList ::= 
            |COMMA ID idList
            ;*/

ifstmt ::= IF LEFT_PARENTHESIS expr LEFT_PARENTHESIS stmt elsestmt
			;


elsestmt ::= ELSE stmt
			|  %prec IF
			;

whilestmt ::= WHILE LEFT_PARENTHESIS expr RIGHT_PARENTHESIS stmt
			;


forstmt ::=  FOR LEFT_PARENTHESIS elist SEMICOLON expr SEMICOLON elist RIGHT_PARENTHESIS stmt
			;


returnstmt ::= RETURN returnStmt SEMICOLON
			;


returnStmt  ::= 
			| expr
			;