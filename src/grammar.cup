import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import ast.Program;
import ast.Statement;
import ast.Expression;
import ast.ExpressionStatement;
import ast.AssignmentExpression;
import ast.Lvalue;
import ast.BinaryExpression;
import ast.UnaryExpression;
import ast.TermExpression;
import ast.Identifier;
import ast.Operator;


parser code
{:
    /** Report a non fatal error (or warning).
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_error(String message, Object info)
    {
        String error = "";
        if (! (info instanceof Symbol))
            info = cur_token;
        if( info instanceof Symbol ) {
            int line = ((Symbol)info).left;
            int column = ((Symbol)info).right;
            error = line  + ":" + column;
        }
        error = error + ": error: " + message;
        System.err.println(error);
        System.err.flush();
    }

    /** Report a fatal error.
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_fatal_error(String   message, Object   info) throws java.lang.Exception
    {
        /* stop parsing (not really necessary since we throw an exception, but) */
        done_parsing();

        /* use the normal error message reporting to put out the message */
        report_error(message, info);

        /* throw an exception */
        throw new Exception("Can't recover from previous error(s)");
    }

    public int getLine() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.left;
    }

    public int getColumn() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.right;
    }
:};


terminal WHILE, FOR, IF, ELSE, RETURN, BREAK, CONTINUE, FUNCTION, TRUE, FALSE, NIL;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, SEMICOLON, COLON, DOLLAR, LEFT_BRACKET, RIGHT_BRACKET, OPEN_BLOCK, CLOSE_BLOCK, DOT, DOUBLE_DOT, COMMA;
terminal DOUBLE_COLON;
terminal ASSIGN;
terminal MUL, DIV, MOD;
terminal PLUS, MINUS, UMINUS, PLUS_PLUS, MINUS_MINUS;
terminal GREATER, LESS, NOT_EQUAL, LESS_OR_EQUAL, GREATER_OR_EQUAL, CMP_EQUAL;
terminal LOGIC_AND, LOGIC_OR, NOT;
terminal QUASI_ESC, QUASI_EXEC, QUASI_OPEN, QUASI_CLOSE;

terminal java.lang.String ID;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Double  REAL_LITERAL;
terminal java.lang.String  STRING_LITERAL;

non terminal Program program;
non terminal ArrayList<Statement> stmtlist;
non terminal Statement stmt;
non terminal Expression expr;
non terminal ArrayList<Expression> exprlist;
non terminal ifstmt;
non terminal elsestmt;
non terminal whilestmt;
non terminal forstmt;
non terminal returnstmt;
non terminal returnStmt;
non terminal block;
non terminal funcdef;
non terminal functionName;
non terminal AssignmentExpression assignexpr;
non terminal TermExpression term;
non terminal Operator op;
non terminal Lvalue lvalue;
non terminal primary;
non terminal call;
non terminal objectdef;
non terminal arraydef;
non terminal const;
non terminal member;
non terminal callsuffix;
non terminal elist;
non terminal normcall;
non terminal methodcall;
non terminal indexed;
non terminal indexedelem;
non terminal idlist;
non terminal idList;

precedence right ASSIGN;
precedence left LOGIC_OR;
precedence left LOGIC_AND;
precedence nonassoc  CMP_EQUAL, NOT_EQUAL;
precedence nonassoc  GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence right NOT,PLUS_PLUS, MINUS_MINUS, UMINUS;
precedence left  DOT, DOUBLE_DOT;
precedence left LEFT_BRACKET, RIGHT_BRACKET;
precedence left  LEFT_PARENTHESIS, RIGHT_PARENTHESIS;
precedence nonassoc IF;
precedence nonassoc ELSE;

start with program;


program ::=	 /*Empty program*/
			 {:
			 	RESULT = new Program();
			 	RESULT.setLine(0);
			 	RESULT.setColumn(0);
			 :}
			| stmtlist:stlist
			 {:
			 	RESULT = new Program(stlist);
			 	RESULT.setLine(stlistleft);
			 	RESULT.setColumn(stlistright);
			 :}
			;

stmtlist  ::= stmt:st
			  {:
			  	RESULT = new ArrayList<Statement>();
			  	RESULT.add(st);
			  :}
			| stmtlist:stlist stmt:st
			  {:
			  	stlist.add(st);
			  	RESULT = stlist;
			  :}
			;


stmt ::=	 expr:ex SEMICOLON
			{:
				RESULT = new ExpressionStatement(ex);
				RESULT.setLine(exleft);
				RESULT.setColumn(exright);
			:}
			|ifstmt
			|whilestmt
			|forstmt
			|returnstmt
			|BREAK SEMICOLON
			|CONTINUE SEMICOLON
			|block
			|funcdef
			|SEMICOLON
			;

expr ::=	assignexpr
			|expr:ex1 op:oper expr:ex2
			{:
				RESULT = new BinaryExpression(oper, ex1, ex2);
				RESULT.setLine(ex1left);
				RESULT.setColumn(ex1right);
			:}
			|term
			;


op ::=       PLUS
            |MINUS
            |MUL
            |DIV
            |MOD
            |GREATER
            |GREATER_OR_EQUAL
            |LESS
            |LESS_OR_EQUAL
            |CMP_EQUAL
            |NOT_EQUAL
            |LOGIC_AND
            |LOGIC_OR
            | NOT
            ;

term ::=	 LEFT_PARENTHESIS expr RIGHT_PARENTHESIS
			|MINUS expr:ex
			{:
				RESULT = new UnaryExpression(Operator.MINUS, ex, null);
				RESULT.setLine(exleft);
				RESULT.setColumn(exright);
			:}
			 %prec UMINUS
			|NOT expr:ex
			{:
				RESULT = new UnaryExpression(Operator.LOGIC_NOT, ex, null);
				RESULT.setLine(exleft);
				RESULT.setColumn(exright);
			:}
			|QUASI_OPEN expr QUASI_CLOSE
			|QUASI_ESC expr
			|QUASI_EXEC expr
			|PLUS_PLUS lvalue:lval
			/*{:
				RESULT = UnaryExpression(Operator.PLUS_PLUS, null, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}*/
			|lvalue:lval PLUS_PLUS
			/*{:
				RESULT = UnaryExpression(Operator.PLUS_PLUS, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}*/
			|MINUS_MINUS lvalue:lval
			/*{:
				RESULT = UnaryExpression(Operator.MINUS_MINUS, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}*/
			|lvalue:lval MINUS_MINUS
			/*{:
				RESULT = UnaryExpression(Operator.MINUS_MINUS, lval);
				RESULT.setLine(lvalleft);
				RESULT.setColumn(lvalright);
			:}*/
			|primary
			;

assignexpr ::= 	lvalue:lval ASSIGN expr:ex
			{:
				//RESULT = new AssignmentExpression();
			:}
			;


primary ::= lvalue
			|call
			|objectdef
			|arraydef
			|LEFT_PARENTHESIS funcdef RIGHT_PARENTHESIS
			|const
			;			

lvalue ::=   ID:id
			{:
				RESULT = new Identifier(id, false);	// boolean value used to indicate local/global scope
				RESULT.setLine(idleft);
				RESULT.setColumn(idright);
			:}
			|DOUBLE_COLON ID:id
			{:
				RESULT = new Identifier(id, true); // boolean value used to indicate local/global scope
				RESULT.setLine(idleft);
				RESULT.setColumn(idright);
			:}
			|member
			;


member ::= lvalue DOT ID
			|lvalue LEFT_BRACKET expr RIGHT_BRACKET
			|call DOT ID
			|call LEFT_BRACKET expr RIGHT_BRACKET
			;



call   ::= call LEFT_PARENTHESIS elist RIGHT_PARENTHESIS
			|lvalue callsuffix
			|LEFT_PARENTHESIS funcdef RIGHT_PARENTHESIS LEFT_PARENTHESIS elist RIGHT_PARENTHESIS			
			;



callsuffix ::= normcall
			|methodcall	
			;



normcall ::= LEFT_PARENTHESIS elist RIGHT_PARENTHESIS
			;


methodcall ::=  DOUBLE_DOT ID LEFT_PARENTHESIS elist RIGHT_PARENTHESIS
			;


elist ::= 
		  |expr exprlist
		  ;


exprlist ::= 
		  |COMMA expr exprlist
		  ;	  


objectdef ::= DOLLAR OPEN_BLOCK indexed CLOSE_BLOCK
		  ;

indexed ::= 
		  | expr COLON expr	indexedelem
		  ;

indexedelem ::=
			|COMMA expr COLON expr indexedelem
			;	  


arraydef::= LEFT_BRACKET elist RIGHT_BRACKET
			;


block ::=   OPEN_BLOCK program CLOSE_BLOCK	
			;	

funcdef ::= FUNCTION  functionName LEFT_PARENTHESIS idlist RIGHT_PARENTHESIS block
			;


functionName::= 
			|ID
			;

const ::= INTEGER_LITERAL
			|REAL_LITERAL
			|STRING_LITERAL
			|NIL
			|TRUE
			|FALSE
			;

idlist ::= 
			|ID idList
			;


idList ::= 
            |COMMA ID idList
            ;

ifstmt ::= IF LEFT_PARENTHESIS expr LEFT_PARENTHESIS stmt elsestmt
			;


elsestmt ::= ELSE stmt
			|  %prec IF 
			;

whilestmt ::= WHILE LEFT_PARENTHESIS expr RIGHT_PARENTHESIS stmt
			;


forstmt ::=  FOR LEFT_PARENTHESIS elist SEMICOLON expr SEMICOLON elist RIGHT_PARENTHESIS stmt
			;


returnstmt ::= RETURN returnStmt SEMICOLON
			;


returnStmt  ::= 
			| expr
			;