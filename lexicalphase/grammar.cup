
/* 
 * HUA Compiler's Course  
 */
import java_cup.runtime.Symbol;

parser code
{:
    /** Report a non fatal error (or warning).
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_error(String message, Object info)
    {
        String error = "";
        if (! (info instanceof Symbol))
            info = cur_token;
        if( info instanceof Symbol ) {
            int line = ((Symbol)info).left;
            int column = ((Symbol)info).right;
            error = line  + ":" + column;
        }
        error = error + ": error: " + message;
        System.err.println(error);
        System.err.flush();
    }

    /** Report a fatal error.
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_fatal_error(String   message, Object   info) throws java.lang.Exception
    {
        /* stop parsing (not really necessary since we throw an exception, but) */
        done_parsing();

        /* use the normal error message reporting to put out the message */
        report_error(message, info);

        /* throw an exception */
        throw new Exception("Can't recover from previous error(s)");
    }

    public int getLine() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.left;
    }

    public int getColumn() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.right;
    }
:};


terminal WHILE, FOR, IF, ELSE, RETURN, BREAK, CONTINUE, FUNCTION, TRUE, FALSE, NIL;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, SEMICOLON, COLON, LEFT_BRACKET, RIGHT_BRACKET, OPEN_BLOCK, CLOSE_BLOCK, DOT, DOUBLE_DOT, COMMA;
terminal DOUBLE_COLON;
terminal ASSIGN;
terminal MUL, DIV, MOD;
terminal PLUS, MINUS, UMINUS, PLUS_PLUS, MINUS_MINUS;
terminal GREATER, LESS, NOT_EQUAL, LESS_OR_EQUAL, GREATER_OR_EQUAL, CMP_EQUAL;
terminal LOGIC_AND, LOGIC_OR, NOT;
terminal QUASI_ESC, QUASI_EXEC;

terminal java.lang.String ID;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Double  REAL_LITERAL;
terminal java.lang.String  STRING_LITERAL;

non terminal program;
non terminal stmt;
non terminal expr;
non terminal exprlist;
non terminal ifstmt;
non terminal whilestmt;
non terminal forstmt;
non terminal returnstmt;
non terminal returnStmt;
non terminal block;
non terminal funcdef;
non terminal functionName;
non terminal assignexpr;
non terminal term;
non terminal op;
non terminal lvalue;
non terminal primary;
non terminal call;
non terminal objectdef;
non terminal arraydef;
non terminal const;
non terminal member;
non terminal callsuffix;
non terminal elist;
non terminal normcall;
non terminal methodcall;
non terminal indexed;
non terminal indexedelem;
non terminal idlist;
non terminal idList;
non terminal elsestmt;

precedence right ASSIGN;
precedence left LOGIC_OR;
precedence left LOGIC_AND;
precedence nonassoc  CMP_EQUAL, NOT_EQUAL;
precedence nonassoc  GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence right NOT,PLUS_PLUS, MINUS_MINUS, UMINUS;
precedence left  DOT, DOUBLE_DOT;
precedence left LEFT_BRACKET, RIGHT_BRACKET;
precedence left  LEFT_PARENTHESIS, RIGHT_PARENTHESIS;
precedence nonassoc IF;
precedence nonassoc ELSE;

start with program;


program ::=	 
			|stmt program
			;


stmt ::=	 expr SEMICOLON
			|ifstmt
			|whilestmt
			|forstmt
			|returnstmt
			|BREAK SEMICOLON
			|CONTINUE SEMICOLON
			|block
			|funcdef
			|SEMICOLON
			;

expr ::=	assignexpr
			|expr op expr
			|term
			;


op ::=       PLUS
            |MINUS
            |MUL
            |DIV
            |MOD
            |GREATER
            |GREATER_OR_EQUAL
            |LESS
            |LESS_OR_EQUAL
            |CMP_EQUAL
            |NOT_EQUAL
            |LOGIC_AND
            |LOGIC_OR
            ;

term ::=	 LEFT_PARENTHESIS expr RIGHT_PARENTHESIS
			|MINUS expr  %prec UMINUS
			|NOT expr
			|DOT LESS expr GREATER DOT
			|DOT QUASI_ESC expr
			|DOT QUASI_EXEC expr
			|PLUS_PLUS lvalue
			|lvalue PLUS_PLUS
			|MINUS_MINUS lvalue
			|lvalue MINUS_MINUS
			|primary
			;

assignexpr ::= 	lvalue ASSIGN expr
			;


primary ::= lvalue
			|call
			|objectdef
			|arraydef
			|LEFT_PARENTHESIS funcdef RIGHT_PARENTHESIS
			|const
			;			

lvalue ::=   ID
			|DOUBLE_COLON ID
			|member
			;			


member ::= lvalue DOT ID
			|lvalue LEFT_BRACKET expr RIGHT_BRACKET
			|call DOT ID
			|call LEFT_BRACKET expr RIGHT_BRACKET
			;



call   ::= call LEFT_PARENTHESIS elist RIGHT_PARENTHESIS
			|lvalue callsuffix
			|LEFT_PARENTHESIS funcdef RIGHT_PARENTHESIS LEFT_PARENTHESIS elist RIGHT_PARENTHESIS			
			;



callsuffix ::= normcall
			|methodcall	
			;



normcall ::= LEFT_PARENTHESIS elist RIGHT_PARENTHESIS
			;


methodcall ::=  DOUBLE_DOT ID LEFT_PARENTHESIS elist RIGHT_PARENTHESIS
			;


elist ::= 
		  |expr exprlist
		  ;


exprlist ::= 
		  |COMMA expr exprlist
		  ;	  


objectdef ::= OPEN_BLOCK indexed CLOSE_BLOCK
		  ;

indexed ::= 
		  | expr COLON expr	indexedelem
		  ;

indexedelem ::=
			|COMMA expr COLON expr indexedelem
			;	  


arraydef::= LEFT_BRACKET elist RIGHT_BRACKET
			;


block ::=   OPEN_BLOCK program CLOSE_BLOCK	
			;	

funcdef ::= FUNCTION  functionName LEFT_PARENTHESIS idlist RIGHT_PARENTHESIS block
			;


functionName::= 
			|ID
			;

const ::= INTEGER_LITERAL
			|REAL_LITERAL
			|STRING_LITERAL
			|NIL
			|TRUE
			|FALSE
			;

idlist ::= 
			|ID idList
			;


idList ::= 
            |COMMA ID idList
            ;

ifstmt ::= IF LEFT_PARENTHESIS expr LEFT_PARENTHESIS stmt elsestmt
			;


elsestmt ::= ELSE stmt
			|  %prec IF 
			;

whilestmt ::= WHILE LEFT_PARENTHESIS expr RIGHT_PARENTHESIS stmt
			;


forstmt ::=  FOR LEFT_PARENTHESIS elist SEMICOLON expr SEMICOLON elist RIGHT_PARENTHESIS stmt
			;


returnstmt ::= RETURN returnStmt SEMICOLON
			;


returnStmt  ::= 
			| expr
			;